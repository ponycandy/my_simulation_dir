1.
restoration failed

查看输出的inf_pr项的最大值，如果是6.28e66这种非常大的值
那么就很有可能是因为
初始化constrain的时候，constrain的数目不对，导致多出来几行没有赋值的约束参数
记得std::cout<<g<<std::endl查看一下

2.Ipopt另一个问题是：、
Converged to a point of local infeasibility. Problem may be infeasible.

一般认为是我们的梯度计算有问题，使用finite-difference-values来试试看能不能求解

我们最好还是用ATGlib来求梯度最不容易出错

3.
优化的提前终止

有的时候，我们只要求目标函数在0.1以下（误差小于0.1）就可以了，这个时候往往不需要
那么多的循环数，那么如何根据objective进行提前终止呢？

    <acceptable_obj_change_tol type="double">
        <value>0.01</value>
    </acceptable_obj_change_tol>
当目标函数的变化值小于一个值的时候提前终止。

4.增大dec_num后无解

5.有一个问题，这个问题或许可以回答为什么含有cost的Ipopt几乎无法求解：
Ifopt库实际上不提供cost的Hession矩阵
这会导致一个相当严重的问题
凡是包含cost的项，都无法使用Ipopt......

这个原因是最为可能的
因为设置自动梯度计算之后
目标函数确实是可以求解的了

这一点在这里有提到：
https://github.com/ethz-adrl/ifopt/issues/41
这就是为什么我们每次添加cost项都会失败的原因了
既然如此，我们将问题转化为全约束形式的吧


5.
事实证明，远来的库没有Hession矩阵，使用的是有限记忆逼近
所以效果非常差
暂时来看，也没有将系统改成能够使用的形式的方法
所以，我们还是尽可能的
将所有问题
转化为纯约束，无cost函数的形式

6.填写Hession的时候，要么都填左下角，要么都填全部，绝对不能够一个填左下角，一个不填

7.优化到一半的时候崩溃。我们已经验证过了1：不是Ipopt本机编译的问题（也就是使用本机编译绝对兼容的ipopt也会有问题） 2：不是oneAPi的问题（退出堆栈中不含有MKL的库，而是直接的ipopt3.dll报错）
   3：不是Ipopt版本的问题（3.14.13最新版本和3.12版本表现绝对一致）4：不是可控范围内指针释放的问题（使用指针和不使用指针结果是一样的）
所以结论是，选择初始值和求解器，将会极大的影响求解结果，并且在某些情况下直接导致求解失败。求解失败的表现不只是restoration failed，还有无警告的直接崩溃。
这很有可能是ipopt源码中存在的设计问题。也就是说，在数值计算中出现的问题
这个问题是无法通过伴随进程解决的（见chatGPT）。所以无解。

目前能够确定的是：1.初始条件不能够太过于接近目标解 2.初始条件最好使用Random，在这两个条件下，问题崩溃的概率会比较低。起码目前条件下
Random初始化的条件还没有出现过崩溃。以及，使用ma27
在上面两条条件加持下进行优化
